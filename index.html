<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TLV & CRC Tool</title> 
  <style>
    body {
      font-family: monospace;
      max-width: 800px;
      margin: 20px auto;
      padding: 20px;
      box-sizing: border-box;
    }

    .center {
      text-align: center;
    }

    img {
      max-width: 100%;
      height: auto;
    }

    textarea { /* This rule now applies to all textareas */
      width: 100%;
      height: 120px;
      font-family: monospace;
      margin-bottom: 10px;
      padding: 10px;
      font-size: 16px;
      box-sizing: border-box;
      resize: none; /* Prevents user from resizing */
      text-align: left; /* Aligns text and placeholder to top-left */
      line-height: 1.5; /* Allows natural multi-line text wrapping */
    }

    button {
      width: 100%;
      padding: 12px;
      font-size: 18px;
      cursor: pointer;
      background-color: #333;
      color: #fff;
      border: none;
      border-radius: 4px;
      margin-bottom: 10px; /* Added margin for separation */
    }

    #mainMenu button {
        margin-top: 10px;
        font-size: 20px;
        padding: 15px;
    }

    /* New style for the "Back to Menu" buttons */
    .back-button {
      background-color: #007bff; /* A distinct blue */
      color: white;
      padding: 15px 12px; /* Slightly more vertical padding */
      font-size: 20px; /* Larger font */
      border: 1px solid #0056b3; /* Darker blue border */
      transition: background-color 0.3s ease, border-color 0.3s ease; /* Smooth transition */
      margin-top: 20px; /* More space above it */
    }

    .back-button:hover {
      background-color: #0056b3; /* Darker blue on hover */
      border-color: #004085; /* Even darker border on hover */
    }

    pre {
      background: #f4f4f4;
      padding: 10px;
      border: 1px solid #ccc;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 20px; /* Base font size for the pre block */
    }

    #greeting {
      font-size: 20px;
      margin-top: 20px;
      font-weight: bold;
    }

    #description {
      font-size: 16px;
      margin-bottom: 10px;
    }

    #crcOutput { /* Style for CRC output */
      font-size: 28px; /* Increased font size for larger display */
      font-weight: bold;
      margin-top: 10px;
      padding: 10px;
      background-color: #e0ffe0; /* Light green background for CRC result */
      border: 1px solid #a0c0a0;
      border-radius: 4px;
      cursor: pointer; /* Indicate it's clickable */
      transition: background-color 0.3s ease; /* Smooth transition for feedback */
    }

    #crcOutput.copied { /* Style for when it's copied */
        background-color: #c0ffc0; /* Darker green */
    }

    /* Styling for the QR code frame */
    .qrcode-frame {
      border: 1px solid #ccc; /* Subtle grey border */
      border-radius: 8px;    /* Rounded corners */
      padding: 15px;         /* Space inside the frame */
      box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.1); /* Light shadow for depth */
      display: inline-block; /* Adjust to content */
      margin-top: 20px;     /* Space above the frame */
      text-align: center; /* To center its content */
    }

    /* Styling for the QR code container inside the frame */
    #qrcodeDisplay {
        background-color: white;
        display: inline-block; /* To allow it to shrink to content size within the frame */
    }

    /* Rule to further ensure centering of the generated QR code element (table/canvas) */
    #qrcodeDisplay table,
    #qrcodeDisplay canvas {
        margin: 10px auto; /* Adds a little top/bottom margin and centers horizontally */
        display: block; /* Ensures margin auto works correctly */
    }

    #qrExtractionResult {
        margin-top: 20px;
        text-align: left;
        padding: 10px;
        background-color: #f9f9f9;
        border: 1px dashed #ddd;
        border-radius: 4px;
        font-size: 15px;
        word-break: break-all;
    }
    #qrExtractionResult strong {
        color: #555;
    }
  </style>
</head>
<body>

  <div id="mainMenu" class="center">
    <h1>TLV & CRC Tool</h1>
    <img src="https://media1.tenor.com/m/bxeM9N2IXLsAAAAd/osita-osita-iheme.gif" alt="Kitty GIF" style="height: 100px; margin-bottom: 20px;"> 
    <h2>Select an Option:</h2>
    <button onclick="showSection('tlvDecoderSection')">Decode Base64</button>
    <button onclick="showSection('crcCheckerSection')">CRC-16 Check Digit</button>
    <button onclick="showSection('qrCodeSection')">Generate QR Code</button> </div>

  <div id="tlvDecoderSection" style="display: none;">
    <div class="center">
        <img src="https://media1.tenor.com/m/bxeM9N2IXLsAAAAd/osita-osita-iheme.gif" alt="Kitty GIF" style="height: 100px;"> 
        <h2>Base64 TLV Decoder</h2>
    </div>
    <textarea id="base64Input" placeholder="Paste Base64 here..."></textarea>
    <button onclick="decodeTLV()">Decode</button>
    <div id="greeting" class="center"></div>
    <div id="description" class="center"></div>

    <pre id="output"></pre>
    <hr>
    <button onclick="showSection('mainMenu')" class="back-button">&#x2190; Back to Menu</button>
  </div>

  <div id="crcCheckerSection" style="display: none;">
    <div class="center">
        <img src="https://media1.tenor.com/m/bxeM9N2IXLsAAAAd/osita-osita-iheme.gif" alt="Kitty GIF" style="height: 100px;"> 
        <h2>CRC-16 Check Digit Calculator</h2>
    </div>
    <textarea id="crcInput" placeholder="Enter string for CRC-16..."></textarea>
    <button onclick="calculateCRC16()">Calculate CRC-16</button>
    <div id="crcOutput" class="center" onclick="copyCrcResult()"></div>
    <hr>
    <button onclick="showSection('mainMenu')" class="back-button">&#x2190; Back to Menu</button>
  </div>

  <div id="qrCodeSection" style="display: none;">
    <div class="center">
        <img src="https://media1.tenor.com/m/bxeM9N2IXLsAAAAd/osita-osita-iheme.gif" alt="Kitty GIF" style="height: 100px;">
        <h2>TLV EMVCo to QR Code Generator</h2> </div>
    <textarea id="qrInput" placeholder="Paste TLV EMVCo data for QR Code..."></textarea> <button onclick="generateQrCodeFeature()">Generate QR Code</button>
    
    <div class="qrcode-frame center"> <div id="qrcodeDisplay"></div> </div>
    
    <div id="qrExtractionResult"></div> <hr>
    <button onclick="showSection('mainMenu')" class="back-button">&#x2190; Back to Menu</button>
  </div>


  <script src="https://cdn.rawgit.com/davidshimjs/qrcodejs/gh-pages/qrcode.min.js"></script>
  <script>
    const tagDescriptions = {
      '85': 'Payload Format Indicator',
      '61': 'Application Template',
      '50': 'Application Label',
      '63': 'Application Specific Transparent Template',
      '9F74': 'Protected Data Envelope',
      '4F': 'AID',
      '5A': 'CPAN',
      '5F20': 'Customer Name',
      '5F2D': 'Language',
      '5F50': 'Mail',
      '9F25': 'Last 4 Digits CPAN',
      '52': 'Merchant Category Code (MCC)', 
      '59': 'Merchant Name (Global)',       
      '60': 'Merchant City (Global)',       
      '62': 'Payment System Specific Template', 
      '70': 'EMV Payment Application Template', // Added for completeness of composite tags
      '26': 'Merchant Account Information Template', // New: for specific extraction
      '01': 'Acquirer Identifier (Sub-tag of 26)', // Sub-tag of 26
      '02': 'MID / GU ID (Sub-tag of 26/51)', // Sub-tag of 26 or 51
      '51': 'Payment System Specific Template (QRIS)' // New composite tag for QRIS
    };

    let qrcodeInstanceForNewSection = null; // To hold the QR code instance for the new QR section

    function showSection(sectionId) {
      const sections = ['mainMenu', 'tlvDecoderSection', 'crcCheckerSection', 'qrCodeSection'];
      sections.forEach(id => {
        document.getElementById(id).style.display = 'none';
      });
      document.getElementById(sectionId).style.display = 'block';

      // Clear previous outputs/inputs when switching sections or returning to main menu
      if (sectionId === 'mainMenu') {
          // Clear TLV Decoder section
          document.getElementById('base64Input').value = '';
          document.getElementById('output').textContent = '';
          document.getElementById('greeting').textContent = '';
          document.getElementById('description').textContent = '';

          // Clear CRC Calculator section
          document.getElementById('crcInput').value = '';
          document.getElementById('crcOutput').textContent = '';

          // Clear QR Code Generator section
          document.getElementById('qrInput').value = '';
          const qrcodeDiv = document.getElementById("qrcodeDisplay");
          if (qrcodeDiv) qrcodeDiv.innerHTML = '';
          qrcodeInstanceForNewSection = null; // Reset QR code instance
          document.getElementById('qrExtractionResult').innerHTML = ''; // Clear extraction results
      } else if (sectionId === 'tlvDecoderSection') {
          // No specific clear needed here as QR code generation moved
      } else if (sectionId === 'crcCheckerSection') {
          // No specific clear needed here
      } else if (sectionId === 'qrCodeSection') {
          // Clear previous QR code and its instance when entering QR section
          const qrcodeDiv = document.getElementById("qrcodeDisplay");
          if (qrcodeDiv) qrcodeDiv.innerHTML = '';
          qrcodeInstanceForNewSection = null;
          document.getElementById('qrExtractionResult').innerHTML = ''; // Clear extraction results
      }
    }

    // Call showSection to initially display the main menu
    document.addEventListener('DOMContentLoaded', () => {
        showSection('mainMenu');
    });

    // parseTLV is for Base64 decoding (standard hex TLV)
    function parseTLV(hex) { // Original name retained for Base64 decoder consistency
      let i = 0;
      const result = {};
      const keepAsHexTags = ['4F', '9F25']; // Tags whose values should remain as hex

      while (i < hex.length) {
        let tag = hex.substr(i, 2);
        i += 2;
        if ((parseInt(tag, 16) & 0x1F) === 0x1F) { // Check for multi-byte tag (first byte ends with 1F)
          while ((parseInt(hex.substr(i, 2), 16) & 0x80) === 0x80) { // Subsequent bytes have MSB set
            tag += hex.substr(i, 2);
            i += 2;
          }
          tag += hex.substr(i, 2); // Last byte of multi-byte tag
          i += 2;
        }

        let lenByte = parseInt(hex.substr(i, 2), 16);
        i += 2;
        let length = lenByte;
        if ((lenByte & 0x80) !== 0) { // Length is multi-byte (first byte has MSB set)
          const lenLen = lenByte & 0x7F; // Number of subsequent bytes for length
          length = parseInt(hex.substr(i, lenLen * 2), 16); // Read actual length
          i += lenLen * 2;
        }

        const valueHex = hex.substr(i, length * 2); // Value is hex string
        i += length * 2;

        // Handle composite tags (templates) recursively
        if (tag === '61' || tag === '63' || tag === '62' || tag === '70' || tag === '26' || tag === '51') { 
          result[tag] = parseTLV(valueHex); // Recursive call using this parser
        } else if (tag === '5A') { // Special handling for CPAN to format as digits
          const digits = valueHex.match(/.{2}/g) 
            .map(byte => {
              const high = (parseInt(byte, 16) >> 4) & 0xF; 
              const low = (parseInt(byte, 16) & 0xF); 
              return `${high}${low}`; 
            }).join('').replace(/F+$/, '').slice(0, 19); 
          result[tag] = digits;
        } else if (keepAsHexTags.includes(tag)) { // Keep specified tags as raw hex
          result[tag] = valueHex.toUpperCase();
        } else { // Default to ASCII conversion
          const ascii = valueHex.match(/.{2}/g)
            .map(h => String.fromCharCode(parseInt(h, 16)))
            .join('').trim();
          result[tag] = ascii;
        }
      }
      return result;
    }


    function format(obj, indent = 0) {
      const pad = '  '.repeat(indent);
      const entries = Object.entries(obj);

      // Prioritize '85' on top
      entries.sort(([a], [b]) => (a === '85' ? -1 : b === '85' ? 1 : 0));

      return entries.map(([k, v]) => {
        const desc = tagDescriptions[k] ? ` [${tagDescriptions[k]}]` : '';
        const keyLabel = `"${k}${desc}"`;
        
        let valueHtml;
        if (typeof v === 'object') {
          valueHtml = `{\n${format(v, indent + 1)}\n${pad}}`;
        } else {
          valueHtml = `<span style="font-weight:bold">${v}</span>`;
        }

        const isHighlighted = (k === '5A' || k === '5F20');
        const highlightStyle = `font-size: 24px; background-color: #FFFF99;`;

        if (isHighlighted) {
            // Wrap the entire line, including leading whitespace, in the highlighting span
            return `<span style="${highlightStyle}">${pad}${keyLabel}: "${valueHtml}"</span>`;
        } else if (typeof v === 'object') {
            return `${pad}${keyLabel}: ${valueHtml}`;
        }
        else {
            return `${pad}${keyLabel}: "${valueHtml}"`;
        }
      }).join(',\n');
    }

    // CRC-16 Calculation Functions
    function crc16(dataString) {
        let crc = 0xFFFF; // Initial value 0xFFFF
        const polynomial = 0x1021; // Polynomial changed to 0x1021

        for (let i = 0; i < dataString.length; i++) {
            let byte = dataString.charCodeAt(i); // Get ASCII value of character
            crc ^= byte << 8; // XOR byte into top of CRC

            for (let j = 0; j < 8; j++) {
                if ((crc & 0x8000) !== 0) { // If MSB is 1
                    crc = (crc << 1) ^ polynomial;
                } else {
                    crc <<= 1;
                }
            }
        }
        // Final XOR value 0x0000 means no operation is needed here as it doesn't change the value.
        return crc & 0xFFFF; // Ensure it's 16-bit
    }

    let originalCrcOutputText = ""; // To store the original text for reverting

    function calculateCRC16() {
        const inputString = document.getElementById("crcInput").value;
        const crcOutputElement = document.getElementById("crcOutput");

        if (inputString) {
            const result = crc16(inputString);
            const hexResult = ("0000" + result.toString(16)).slice(-4).toUpperCase(); 
            originalCrcOutputText = hexResult; // Store the actual result
            crcOutputElement.textContent = hexResult;
        } else {
            originalCrcOutputText = "Please enter a string to calculate CRC-16."; // Store the error message
            crcOutputElement.textContent = originalCrcOutputText;
        }
        crcOutputElement.classList.remove('copied'); // Ensure 'copied' class is removed on new calculation
    }

    function copyCrcResult() {
        const crcOutputElement = document.getElementById("crcOutput");
        const textToCopy = crcOutputElement.textContent;

        // Prevent copying the "Please enter..." message
        if (textToCopy === "Please enter a string to calculate CRC-16." || textToCopy === "Copied!") {
            return;
        }

        navigator.clipboard.writeText(textToCopy)
            .then(() => {
                crcOutputElement.textContent = "Copied!";
                crcOutputElement.classList.add('copied');
                setTimeout(() => {
                    crcOutputElement.textContent = originalCrcOutputText;
                    crcOutputElement.classList.remove('copied');
                }, 1500); // Revert after 1.5 seconds
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                // Optionally provide a different error message to the user
                crcOutputElement.textContent = "Copy Failed!";
                setTimeout(() => {
                    crcOutputElement.textContent = originalCrcOutputText;
                }, 1500);
            });
    }

    // Helper function to extract specific details from parsed TLV for QR Code section
    function extractQrDetails(parsedTlv) {
        let nmId = 'N/A';
        let merchantName = 'N/A';
        let merchantCity = 'N/A';
        let acquirer = 'N/A';
        let mid = 'N/A'; // New field for MID

        // NMID: Tag 51 subtag 02 (as per user's example)
        if (parsedTlv['51'] && parsedTlv['51']['02']) {
            nmId = parsedTlv['51']['02'];
        }

        // Merchant Name: Tag 59 (as per user's example)
        if (parsedTlv['59']) {
            merchantName = parsedTlv['59'];
        } 

        // Merchant City: Tag 60 (as per user's example)
        if (parsedTlv['60']) {
            merchantCity = parsedTlv['60'];
        } 

        // Acquirer: Tag 26 subtag 01, substring 8 digits (as per user's example)
        if (parsedTlv['26'] && parsedTlv['26']['01']) {
            acquirer = parsedTlv['26']['01'].substring(0, 8);
        }

        // MID: Tag 26 subtag 02 (as per user's example)
        if (parsedTlv['26'] && parsedTlv['26']['02']) {
            mid = parsedTlv['26']['02'];
        }

        return { merchantName, merchantCity, nmId, acquirer, mid };
    }

    // New parser specifically for EMVCo QR code format (decimal lengths, ASCII values)
    function parseCustomQRTLV(tlvString) {
        let i = 0;
        const result = {};

        while (i < tlvString.length) {
            let tag = tlvString.substr(i, 2); // Tags are 2 hex chars (1 byte)
            i += 2;

            let lenStr = tlvString.substr(i, 2); // Lengths are 2 ASCII chars (e.g., "25")
            i += 2;
            let length = parseInt(lenStr, 10); // Parse Length as DECIMAL

            let value = tlvString.substr(i, length); // Value is 'length' ASCII characters
            i += length;

            // Common composite tags in EMVCo QR that might contain further custom TLV
            if (['26', '51', '62', '64'].includes(tag)) { // Added '26', '51', '62', '64' for common EMVCo QR composite tags
                try {
                    result[tag] = parseCustomQRTLV(value); // Recursive call using this custom parser
                } catch (e) {
                    console.error(`Error parsing nested custom TLV for tag ${tag}:`, value, e);
                    result[tag] = `ERROR_PARSING_COMPOSITE(${value})`; // Indicate parsing error
                }
            } else {
                result[tag] = value; // Assign value directly (it's already ASCII)
            }
        }
        return result;
    }

    // Function to generate QR Code, also calls extraction automatically
    function generateQrCodeFeature() {
        const inputData = document.getElementById("qrInput").value.trim(); // Get data from new QR textarea
        const qrcodeDiv = document.getElementById("qrcodeDisplay"); // Target the new QR display div
        const extractionResultDiv = document.getElementById("qrExtractionResult");
        
        // Clear previous QR code and error messages
        qrcodeDiv.innerHTML = ''; 
        extractionResultDiv.innerHTML = ''; // Clear previous extraction results
        
        if (!inputData) {
            qrcodeDiv.textContent = "Please paste TLV EMVCo data to generate QR code.";
            extractionResultDiv.innerHTML = `<p style="color: red;">Please paste TLV EMVCo data to extract details.</p>`;
            return;
        }

        // Parse and extract details first using the custom parser
        let parsedTlvData;
        try {
            parsedTlvData = parseCustomQRTLV(inputData); // Use the new custom parser here
            const { merchantName, merchantCity, nmId, acquirer, mid } = extractQrDetails(parsedTlvData);
            
            extractionResultDiv.innerHTML = `
                <h3>Extracted Details:</h3>
                <p><strong>NMID:</strong> ${nmId}</p>
                <p><strong>Merchant Name:</strong> ${merchantName}</p>
                <p><strong>Merchant City:</strong> ${merchantCity}</p>
                <p><strong>Acquirer:</strong> ${acquirer}</p>
                <p><strong>MID:</strong> ${mid}</p>
            `;
        } catch (e) {
            console.error("Error parsing TLV for extraction:", e);
            extractionResultDiv.innerHTML = `<p style="color: red;">Error extracting details: Invalid TLV format or unexpected error. Please check your TLV data.</p>`;
            // If parsing fails, don't generate QR code to avoid misleading result
            qrcodeDiv.textContent = "Error: Could not generate QR due to invalid TLV data for extraction.";
            return;
        }

        // Generate QR Code
        qrcodeInstanceForNewSection = new QRCode(qrcodeDiv, {
            text: inputData,
            width: 256, // Larger size
            height: 256, // Larger size
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H // High error correction
        });
    }
  </script>
</body>
</html>
